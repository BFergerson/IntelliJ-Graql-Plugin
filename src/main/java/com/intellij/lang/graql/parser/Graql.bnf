{
    parserClass="com.intellij.lang.graql.parser.GraqlParser"
    parserUtilClass="com.intellij.lang.parser.GeneratedParserUtilBase"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
    extends(".*Pattern")=pattern

    psiClassPrefix="Graql"
    psiImplClassSuffix="Impl"
    psiPackage="com.intellij.lang.graql.psi"
    psiImplPackage="com.intellij.lang.graql.psi.impl"
    psiImplUtilClass="com.intellij.lang.graql.psi.impl.GraqlPsiImplUtil"

    elementTypeHolderClass="com.intellij.lang.graql.psi.GraqlTokenTypes"
    elementTypeClass="com.intellij.lang.graql.psi.GraqlElementType"
    tokenTypeClass="com.intellij.lang.graql.psi.GraqlTokenType"

    tokens=[
        AT                  = '@'
        LBR                 = '['
        RBR                 = ']'
        period              = '.'
        colon               = ':'
        semicolon           = ';'
        comma               = ','
        LPAREN              = '('
        RPAREN              = ')'
        LBRACE              = '{'
        RBRACE              = '}'
        LESS                = '<'
        LESSEQ              = '<='
        GREATER             = '>'
        GREATEREQ           = '>='
        EQ                  = '='
        NEQ                 = '!='
        sub                 = 'sub'
        key                 = 'key'
        has                 = 'has'
        plays               = 'plays'
        relates             = 'relates'
        role                = 'role'
        relationship        = 'relationship'
        entity              = 'entity'
        attribute           = 'attribute'
        datatype            = 'datatype'
        long                = 'long'
        double              = 'double'
        string              = 'string'
        date                = 'date'
        boolean             = 'boolean'
        via                 = 'via'
        isa                 = 'isa'
        commit              = 'commit'
        define              = 'define'
        insert              = 'insert'
        match               = 'match'
        rule                = 'rule'
        when                = 'when'
        then                = 'then'
        get                 = 'get'
        compute             = 'compute'
        cluster             = 'cluster'
        in                  = 'in'
        member              = 'member'
        label               = 'label'
        is-abstract         = 'is-abstract'
        as                  = 'as'
        delete              = 'delete'
        aggregate           = 'aggregate'
        ask                 = 'ask'
        count               = 'count'
        sum                 = 'sum'
        max                 = 'max'
        min                 = 'min'
        mean                = 'mean'
        median              = 'median'
        group               = 'group'
        of                  = 'of'
        std                 = 'std'
        val                 = 'val'
        contains            = 'contains'
        or                  = 'or'
        offset              = 'offset'
        limit               = 'limit'
        order               = 'order'
        by                  = 'by'
        asc                 = 'asc'
        desc                = 'desc'
        true                = 'true'
        false               = 'false'
        for                 = 'for'
        do                  = 'do'
        if                  = 'if'
        not                 = 'not'
        else                = 'else'
        null                = 'null'

        STRING_LITERAL      = "regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
        REGEX               = "regexp:/([^\\\/]+)/"
        INTEGER             = "regexp:([-+]?\d+)"
        space               = 'regexp:\s+'
        single_line_comment = 'regexp:#.*'
        ID                  = 'regexp:[a-zA-Z_0-9-]*'
        VARIABLE            = 'regexp:\$[a-zA-Z0-9_-]*'
    ]
}

GraqlFile ::= !<<eof>> (query)*

query ::= getQuery | insertQuery | defineQuery | undefineQuery | deleteQuery | aggregateQuery | computeQuery | statement

matchPart ::= MATCH patterns (matchLimitOffset|matchOffsetLimit)? matchOrderBy? blockContents?
matchLimitOffset ::= matchLimit matchOffset?
matchOffsetLimit ::= matchOffset matchLimit?
matchLimit ::= 'limit' INTEGER ';' // matchLimit
matchOffset ::= 'offset' INTEGER ';' // matchOffset
matchOrderBy ::= 'order' 'by' VARIABLE (asc|desc)? ';' // matchOrderBy

getQuery ::= matchPart ('get' (VARIABLE (',' VARIABLE)*)? ';')?
insertQuery ::= matchPart? INSERT varPatterns? (variable? blockContents?)
defineQuery ::= DEFINE varPatterns
undefineQuery ::= UNDEFINE varPatterns
deleteQuery ::= matchPart 'delete' variables? ';'
aggregateQuery ::= matchPart 'aggregate' aggregate ';'
computeQuery ::= 'compute' computeMethod

variables ::= VARIABLE (',' VARIABLE)*

computeMethod ::= min | max | median | mean | std | sum | count | path | paths | cluster | degrees

min ::= MIN         'of' ofList         ('in' inList)? ';'
max ::= MAX         'of' ofList         ('in' inList)? ';'
median ::= MEDIAN   'of' ofList         ('in' inList)? ';'
mean ::= MEAN       'of' ofList         ('in' inList)? ';'
std ::= STD         'of' ofList         ('in' inList)? ';'
sum ::= SUM         'of' ofList         ('in' inList)? ';'
degrees ::= DEGREES ('of' ofList)?      ('in' inList)? ';'
cluster ::= CLUSTER ('of' id    )?      ('in' inList)? ';' clusterParam*
path ::= PATH       'from' id 'to' id   ('in' inList)? ';'
paths ::= PATHS     'from' id 'to' id   ('in' inList)? ';'
count ::= COUNT                         ('in' inList)? ';'

clusterParam ::= MEMBERS ';'    // clusterMembers
   | SIZE INTEGER ';'           // clusterSize

ofList ::= labelList
inList ::= labelList
labelList ::= label (',' label)*

aggregate ::= identifier argument*      // customAgg
    | '(' namedAgg (',' namedAgg)* ')'  // selectAgg
argument ::= VARIABLE  // variableArgument
    | aggregate        // aggregateArgument
namedAgg ::= aggregate 'as' identifier

patterns ::= (pattern (','|';')?)+
pattern ::= varPattern          // varPatternCase
    | orPattern                 // orPattern
    | andPattern                // andPattern
andPattern ::= LBRACE patterns RBRACE
orPattern ::= pattern 'or' pattern

varPatterns ::= (varPattern ';'?)+
varPattern ::= variable? property (','? property)*

property ::= 'isa' variable             // isa
    | 'isa' escapedExpression           // isa
    | 'sub' variable                    // sub
    | 'relates' variable                // relates
    | 'plays' variable                  // plays
    | 'id' id                           // propId
    | 'label' label                     // propLabel
    | 'val' predicate                   // propValue
    | 'val' escapedExpression           // propValue
    | 'when' LBRACE patterns RBRACE     // propWhen
    | 'then' LBRACE varPatterns RBRACE  // propThen
    | 'has' label predicate             // propHas
    | 'has' label escapedExpression     // propHas
    | 'has' variable                    // propResource
    | 'has' property                    // propHasProp?
    | 'key' variable                    // propKey
    | '(' casting (',' casting)* ')'    // propRel
    | 'is-abstract'                     // isAbstract
    | 'datatype' (long|double|string|boolean|date)  // propDatatype
    | 'regex' REGEX                     // propRegex
    | NEQ variable                     // propNeq
    | ';'

casting ::= variable (':' VARIABLE)?
    | variable VARIABLE

variable ::= label | VARIABLE

predicate ::= EQ? value                // predicateEq
    | EQ? VARIABLE                     // predicateVariable
    | NEQ valueOrVar                   // predicateNeq
    | '>' valueOrVar                    // predicateGt
    | '>=' valueOrVar                   // predicateGte
    | '<' valueOrVar                    // predicateLt
    | '<=' valueOrVar                   // predicateLte
    | 'contains' (STRING_LITERAL | VARIABLE)    // predicateContains
    | REGEX                             // predicateRegex
valueOrVar ::= VARIABLE // valueVariable
    | value             // valuePrimitive
value ::= STRING_LITERAL   // valueString
   | INTEGER  // valueInteger
   | REAL     // valueReal
   | (true|false)  // valueBoolean
   | DATE     // valueDate
   | DATETIME // valueDateTime

label ::= identifier | IMPLICIT_IDENTIFIER
id ::= identifier

identifier ::= ID | STRING_LITERAL
    | MIN | MAX| MEDIAN | MEAN | STD | SUM | COUNT | PATH | CLUSTER | DATE
    | DEGREES | MEMBERS | SIZE | ENTITY | RELATIONSHIP | RULE | ROLE | ATTRIBUTE | VAL {
    mixin="com.intellij.lang.graql.psi.impl.GraqlNamedElementImpl"
    implements="com.intellij.lang.graql.psi.GraqlNamedElement"
    methods=[getName setName getNameIdentifier]
}

//Graql template extension
escapedExpression ::= untypedExpression;
untypedExpression ::= '<' id accessor* '>'                              //idExpression
    | MACRO_NOESCP
    | MACRO_EQUALS
    | ID_MACRO LPAREN expression? (',' expression)* RPAREN accessor?    //macroExpression
    | id

ID_MACRO ::= AT (MACRO_NOESCP|ID|int|long|double|boolean|date)
MACRO_NOESCP ::= AT noescp LPAREN expression? (',' expression)* RPAREN accessor? identifier?
MACRO_EQUALS ::= AT equals LPAREN expression? (',' expression)* RPAREN accessor?

accessor ::= period id     //mapAccessor
    | LBR int_ RBR      //listAccessor

block ::= LBRACE blockContents RBRACE ';'?
blockContents ::= (statement | escapedExpression | query | patterns)*

statement ::= forInStatement
    | forEachStatement
    | ifStatement

forInStatement   ::= FOR LPAREN identifier IN escapedExpression RPAREN DO block
forEachStatement ::= FOR LPAREN escapedExpression RPAREN DO block

ifStatement   ::= ifPartial elseIfPartial* elsePartial?
ifPartial     ::= IF LPAREN bool RPAREN DO block
elseIfPartial ::= ELSEIF LPAREN bool RPAREN DO block
elsePartial   ::= ELSE block

expression    ::= untypedExpression | nil | STRING_LITERAL | number | (true|false)
number        ::= untypedExpression | int_ | double_
int_          ::= untypedExpression | INTEGER
double_       ::= untypedExpression | DOUBLE
list          ::= untypedExpression
nil           ::= NULL
bool ::= expression EQ expression           //eqExpression
    | expression NEQ expression             //NEQExpression
    | number GREATER number                 //greaterExpression
    | number GREATEREQ number               //greaterEqExpression
    | number LESS number                    //lessExpression
    | number LESSEQ number                  //lessEqExpression
    | untypedExpression                     //booleanExpression
    | (true|false)                          //booleanConstant
    | orBool
    | andBool
    | notBool
    | groupBool
groupBool ::= LPAREN bool RPAREN
orBool ::= groupBool OR groupBool
andBool ::= groupBool AND groupBool
notBool ::= NOT groupBool