{
    parserClass="com.intellij.lang.graql.parser.GraqlParser"
    parserUtilClass="com.intellij.lang.parser.GeneratedParserUtilBase"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
    extends(".*Pattern")=pattern

    psiClassPrefix="Graql"
    psiImplClassSuffix="Impl"
    psiPackage="com.intellij.lang.graql.psi"
    psiImplPackage="com.intellij.lang.graql.psi.impl"
    psiImplUtilClass="com.intellij.lang.graql.psi.impl.GraqlPsiImplUtil"

    elementTypeHolderClass="com.intellij.lang.graql.psi.GraqlTokenTypes"
    elementTypeClass="com.intellij.lang.graql.psi.GraqlElementType"
    tokenTypeClass="com.intellij.lang.graql.psi.GraqlTokenType"

    tokens=[
        colon               = ':'
        semicolon           = ';'
        comma               = ','
        LPAREN              = '('
        RPAREN              = ')'
        LBRACE              = '{'
        RBRACE              = '}'
        LTHAN               = '<'
        LTHANEQ             = '<='
        GTHAN               = '>'
        GTHANEQ             = '>='
        sub                 = 'sub'
        key                 = 'key'
        has                 = 'has'
        plays               = 'plays'
        relates             = 'relates'
        role                = 'role'
        relationship        = 'relationship'
        entity              = 'entity'
        attribute           = 'attribute'
        datatype            = 'datatype'
        long                = 'long'
        double              = 'double'
        string              = 'string'
        date                = 'date'
        boolean             = 'boolean'
        via                 = 'via'
        isa                 = 'isa'
        commit              = 'commit'
        define              = 'define'
        insert              = 'insert'
        match               = 'match'
        rule                = 'rule'
        when                = 'when'
        then                = 'then'
        get                 = 'get'
        compute             = 'compute'
        cluster             = 'cluster'
        in                  = 'in'
        member              = 'member'
        label               = 'label'
        is-abstract         = 'is-abstract'
        as                  = 'as'
        delete              = 'delete'
        aggregate           = 'aggregate'
        ask                 = 'ask'
        count               = 'count'
        sum                 = 'sum'
        max                 = 'max'
        min                 = 'min'
        mean                = 'mean'
        median              = 'median'
        group               = 'group'
        of                  = 'of'
        std                 = 'std'
        val                 = 'val'
        contains            = 'contains'
        or                  = 'or'
        offset              = 'offset'
        limit               = 'limit'
        order               = 'order'
        by                  = 'by'
        asc                 = 'asc'
        desc                = 'desc'
        true                = 'true'
        false               = 'false'

        STRING              = "regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
        REGEX               = "regexp:/([^\\\/]+)/"
        INTEGER             = "regexp:([-+]?\d+)"
        space               = 'regexp:\s+'
        single_line_comment = 'regexp:#.*'
        ID                  = 'regexp:[a-zA-Z_0-9-]*'
        VARIABLE            = 'regexp:\$[a-zA-Z0-9_-]*'
    ]
}

GraqlFile ::= !<<eof>> (query)*

query ::= getQuery | insertQuery | defineQuery | undefineQuery | deleteQuery | aggregateQuery //| computeQuery

matchPart ::= MATCH patterns (matchLimitOffset|matchOffsetLimit)? matchOrderBy?
matchLimitOffset ::= matchLimit matchOffset?
matchOffsetLimit ::= matchOffset matchLimit?
matchLimit ::= 'limit' INTEGER ';' // matchLimit
matchOffset ::= 'offset' INTEGER ';' // matchOffset
matchOrderBy ::= 'order' 'by' VARIABLE (asc|desc)? ';' // matchOrderBy

getQuery ::= matchPart ('get' (VARIABLE (',' VARIABLE)*)? ';')
insertQuery ::= matchPart? INSERT varPatterns
defineQuery ::= DEFINE varPatterns
undefineQuery ::= UNDEFINE varPatterns
deleteQuery ::= matchPart 'delete' variables? ';'
aggregateQuery ::= matchPart 'aggregate' aggregate ';'
//computeQuery ::= 'compute' computeMethod

variables ::= VARIABLE (',' VARIABLE)*

//computeMethod ::= min | max | median | mean | std | sum | count | path | paths | cluster | degrees
//
//min ::= MIN         'of' ofList         ('in' inList)? ';'
//max ::= MAX         'of' ofList         ('in' inList)? ';'
//median ::= MEDIAN   'of' ofList         ('in' inList)? ';'
//mean ::= MEAN       'of' ofList         ('in' inList)? ';'
//std ::= STD         'of' ofList         ('in' inList)? ';'
//sum ::= SUM         'of' ofList         ('in' inList)? ';'
//degrees ::= DEGREES ('of' ofList)?      ('in' inList)? ';'
//cluster ::= CLUSTER ('of' id    )?      ('in' inList)? ';' clusterParam*
//path ::= PATH       'from' id 'to' id   ('in' inList)? ';'
//paths ::= PATHS     'from' id 'to' id   ('in' inList)? ';'
//count ::= COUNT                         ('in' inList)? ';'

clusterParam ::= MEMBERS ';'    // clusterMembers
   | SIZE INTEGER ';'           // clusterSize

ofList ::= labelList
inList ::= labelList
labelList ::= label (',' label)*

aggregate ::= identifier argument*      // customAgg
    | '(' namedAgg (',' namedAgg)* ')'  // selectAgg
argument ::= VARIABLE  // variableArgument
    | aggregate        // aggregateArgument
namedAgg ::= aggregate 'as' identifier

patterns ::= (pattern ';')+
pattern ::= varPattern          // varPatternCase
    | orPattern                 // orPattern
    | andPattern                // andPattern
andPattern ::= '{' patterns '}'
orPattern ::= pattern 'or' pattern

varPatterns ::= (varPattern ';')+
varPattern ::= variable? property (','? property)*

property ::= 'isa' variable             // isa
    | 'sub' variable                    // sub
    | 'relates' variable                // relates
    | 'plays' variable                  // plays
    | 'id' id                           // propId
    | 'label' label                     // propLabel
    | 'val' predicate                   // propValue
    | 'when' '{' patterns '}'           // propWhen
    | 'then' '{' varPatterns '}'        // propThen
    | 'has' label predicate             // propHas
    | 'has' variable                    // propResource
    | 'key' variable                    // propKey
    | '(' casting (',' casting)* ')'    // propRel
    | 'is-abstract'                     // isAbstract
    | 'datatype' (long|double|string|boolean|date)  // propDatatype
    | 'regex' REGEX                     // propRegex
    | '!=' variable                     // propNeq

casting ::= variable (':' VARIABLE)?
    | variable VARIABLE

variable ::= label | VARIABLE

predicate ::= '='? value                // predicateEq
    | '='? VARIABLE                     // predicateVariable
    | '!=' valueOrVar                   // predicateNeq
    | '>' valueOrVar                    // predicateGt
    | '>=' valueOrVar                   // predicateGte
    | '<' valueOrVar                    // predicateLt
    | '<=' valueOrVar                   // predicateLte
    | 'contains' (STRING | VARIABLE)    // predicateContains
    | REGEX                             // predicateRegex
valueOrVar ::= VARIABLE // valueVariable
    | value             // valuePrimitive
value ::= STRING   // valueString
   | INTEGER  // valueInteger
   | REAL     // valueReal
   | (true|false)  // valueBoolean
   | DATE     // valueDate
   | DATETIME // valueDateTime

label ::= identifier | IMPLICIT_IDENTIFIER
id ::= identifier

// Some keywords can also be used as identifiers
identifier ::= ID | STRING
    | MIN | MAX| MEDIAN | MEAN | STD | SUM | COUNT | PATH | CLUSTER
    | DEGREES | MEMBERS | SIZE | ENTITY | RELATIONSHIP | RULE {
    mixin="com.intellij.lang.graql.psi.impl.GraqlNamedElementImpl"
    implements="com.intellij.lang.graql.psi.GraqlNamedElement"
    methods=[getName setName getNameIdentifier]
}